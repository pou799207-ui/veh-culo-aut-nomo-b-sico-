Gestión de movilidad

Gestión de movilidad.
Nuestro vehículo autónomo básico tiene cuatro movimientos, los cuales son: adelante, atrás, izquierda y derecha. El carro cuenta con dos motores tipo DC130 de 3V-6V, uno que funciona como motor de potencia y el otro como dirección. 
Motor de dirección:
Este motor utiliza un mecanismo que primero convierte el movimiento horizontal del eje del motor en un movimiento circular mediante un engranaje de proporción adecuada. A partir de ese segundo engranaje se transmite el movimiento necesario para operar correctamente el sistema de dirección Ackermann. El sistema Ackermann es un mecanismo que permite que las ruedas delanteras giren con ángulos distintos al tomar una curva, de modo que ambas sigan un mismo centro de giro y no derrapen. Esto se logra mediante una geometría precisa de barras y pivotes que hace que la rueda interna gire más que la externa, proporcionando giros más estables, suaves y controlados, tanto en vehículos reales como en robots.
Motor de potencia:
En este sistema de engranajes del motor, el movimiento inicia en el motor, cuyo eje lleva un engrane muy pequeño (piñón) que gira a gran velocidad pero con poca fuerza; este piñón mueve un engranaje grande, lo que produce la primera reducción de velocidad y un aumento importante de torque. Ese engranaje grande tiene unido en el mismo eje un engrane pequeño, que gira a la misma velocidad que el grande y transmite la fuerza ya amplificada hacia la siguiente etapa. Luego, este segundo engrane pequeño mueve un último engrane grande, generando una segunda reducción que disminuye aún más la velocidad y aumenta al máximo el torque disponible para el eje final. Gracias a estas dos etapas de reducción, el sistema convierte las altas revoluciones del motor en un movimiento mucho más lento pero suficientemente fuerte para mover las ruedas del vehículo con estabilidad y potencia.
 
Diseño 
El chasis de nuestro vehículo fue un modelo de carro ULTRAX RC (racing machine) que se encontró en una tienda física, las modificaciones que se le realizaron a nuestro vehículo fueron agregarle un controlador en este caso fue una sp32, dos motores uno para dirección y otro para la potencia, tres sensores ultrasónicos, uno en la parte de enfrente, uno en la parte derecha y otro en la parte izquierda, una batería de 7.5V y 2200mAh y un puente h. Todas estas conexiones se realizaron con jumpers. 
Para que el carro avance sus motores se utilizaron motores de 5V, los cuales nos ofrecen una potencia buena para alimentar el carrito ya que un motor solo es para la dirección del vehículo. Nuestro motor se implementa a partir de un  modelo de engranajes para que pueda tener la movilidad del movimiento al eje que está compartido por las dos llantas. 
Nuestro vehículo cuenta con el sistema de ackerman que ayuda para el movimiento de las ruedas delanteras. 


Gestión de la potencia y los sentidos 

Potencia 

Para garantizar una distribución eficiente y estable de la energía dentro del sistema, se emplearon dos baterías con funciones específicas. La batería principal de 7.5 V y 2200 mA es la encargada de suministrar potencia a los componentes críticos del dispositivo. Esta batería se conecta a un puente H L298N, el cual gestiona y distribuye adecuadamente la energía hacia los dos motores: el motor de potencia y el motor de dirección. Además, gracias a la salida regulada de 5 V que incorpora el propio puente H, es posible alimentar de manera segura a la ESP32, asegurando su correcto funcionamiento mediante la unión de las tierras tanto de la batería principal como de la tarjeta de control, lo que permite mantener un mismo punto de referencia eléctrico.

Por otro lado, se incorporó una batería secundaria de 3 V y 200 mA, destinada exclusivamente a la alimentación de los tres sensores ultrasónicos ubicados en la parte frontal, lateral izquierda y lateral derecha del sistema. Esta separación de fuentes permite evitar interferencias, caídas de voltaje o ruidos eléctricos que pudieran afectar la precisión de los sensores o la estabilidad del microcontrolador.

Finalmente, todas las conexiones fueron realizadas mediante jumpers y puntos de soldadura, asegurando un ensamblaje firme, confiable y adecuado para el funcionamiento continuo del circuito.

Potencia de los motores 

Para el control de los motores se utilizaron las entradas Enable A y Enable B del puente H L298N, las cuales permiten gestionar adecuadamente la modulación por ancho de pulso (PWM) aplicada a cada motor. Esta configuración es fundamental para regular la potencia entregada y, por lo tanto, la velocidad y el comportamiento dinámico del sistema. La lógica de programación se diseñó con base en una regulación precisa de potencia; considerando el rango estándar de PWM de 0 a 255, se determinó un valor de 200 para el motor principal de tracción. Esta selección permite obtener una velocidad suficientemente alta para un desplazamiento eficiente, pero sin exceder los límites mecánicos o comprometer la estabilidad del vehículo.

En cuanto al motor de dirección, su gestión requirió un análisis más minucioso debido a que no funciona como un servomotor —que normalmente posee un control interno de posición—, sino como un motor de rotación continua, lo cual dificulta la delimitación exacta de los ángulos de giro. Este comportamiento implicó un reto importante, pues fue necesario evaluar cuántas vueltas debía ejecutar el motor para que el engranaje acoplado realizara el movimiento correcto sin generar tensiones excesivas ni provocar un desajuste mecánico. Tras múltiples pruebas y observaciones, y considerando la geometría específica del engrane utilizado, se determinó que la operación óptima del motor de dirección se alcanza con un PWM de 80, acompañado de un delay de 20 ms, logrando así un giro controlado, seguro y funcional.

Sensores    
   
Los sensores utilizados para nuestro vehículo autónomo básico fueron sensores ultrasonidos, se eligieron porque su detección a corta distancia ya que para las vueltas necesitamos una buena detección de sensores, además de que no dependen de la luz, también no son sensibles al ruido y miden la distancia directamente.
Se utilizaron poniéndolos en lugares estratégicos de nuestro vehículo, los cuales fueron uno en los lados y otro al frente.

Enfrente
El sensor frontal detectaba más fácilmente cuando tenía que frenar, retroceder o dar un giro y hacía que dirección y tener una mejor visión. 

Lado derecho/izquierdo:
Estos sensores los pusimos porque pueden medir el lado libre y para hacer lo giros más seguros, ya que así detecta más fácilmente si tenía que ir en sentido horario o antihorario y evitar chocar en los giros. 



Gestión de obstáculos 
Descripción del código:
Este código controla un vehículo autónomo basado en una ESP32 que utiliza tres sensores ultrasónicos (frontal, derecho e izquierdo) para medir distancias y dos motores:uno de potencia para avanzar o retroceder y otro de dirección para girar. Primero se definen las variables y los pines de todos los componentes, luego se incluye una función que activa y lee los sensores ultrasónicos para obtener la distancia. Se implementan funciones para mover el motor principal (avanzar, retroceder y detener) y para girar el motor de dirección hacia la izquierda o derecha, incluyendo pequeños movimientos temporizados para corregir la orientación y luego centrar la dirección. En el loop principal, el robot mide continuamente las distancias y toma decisiones: si el camino frontal está libre avanza recto; si hay un obstáculo compara la distancia lateral para decidir si girar a la derecha o izquierda; si alguna distancia es muy pequeña retrocede para evitar choques; y si ambos lados son iguales retrocede ligeramente y se detiene.

Código:
Primero, se definen las variables, en este caso variables de distancia provenientes de los sensores ultrasónicos delantero, derecho e izquierdo.
int DISTANCIASensorA = 0;
int DISTANCIASensorD = 0;
int DISTANCIASensorI = 0;

// Motor de dirección (D), el cual tiene 3 pines, los 2 primeros que van directo al motor, y un tercero que funciona con PWM.
int MotorD1 = 13;
int MotorD2 = 12;
int MotorDENA = 14;

// Motor de potencia (P), el cual tiene 3 pines, los 2 primeros que van directo al motor, y un tercero que funciona con PWM.

int pinMotorP1 = 27;
int pinMotorP2 = 26;
int MotorDENAP = 19;

// Ahora, definir en qué pines  de la ESP32 se van a conectar los sensores.
int SensorApinEco = 5;
int SensorApinGatillo = 17;

int SensorDpinEco = 16;
int SensorDpinGatillo = 4;

int SensorIpinEco = 15;
int SensorIpinGatillo = 2;

// FUNCIONES DE SENSORES
//Hacer funcionar los sensores para que estén emitiendo señales y recibiendo señales constantemente.
long leerUltrasonico(int trigger, int echo) {
  pinMode(trigger, OUTPUT);
  digitalWrite(trigger, LOW);
  delayMicroseconds(2);
  digitalWrite(trigger, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigger, LOW);

  pinMode(echo, INPUT);
  return pulseIn(echo, HIGH);
}


// FUNCIONES DE MOTORES

  //Motor P (avanzar, retroceder, detener)  
  void avanzar() {
  digitalWrite(pinMotorP1, HIGH);
  digitalWrite(pinMotorP2, LOW);
  analogWrite(MotorDENAP, 200);
}

void retroceder() {
  digitalWrite(pinMotorP1, LOW);
  digitalWrite(pinMotorP2, HIGH);
  analogWrite(MotorDENAP, 200);
}

void detenerMotorP() {
  digitalWrite(pinMotorP1, LOW);
  digitalWrite(pinMotorP2, LOW);
}

// Motor D (dirección)
void girarDerecha() {
//Avanza a una velocidad controlada 
    digitalWrite(pinMotorP1, HIGH);
    digitalWrite(pinMotorP2, LOW);
    analogWrite(MotorDENAP, 80);
    // Gira hacia un lado 2 segundos
    digitalWrite(MotorD1, LOW);
    digitalWrite(MotorD2, HIGH);
    analogWrite(MotorDENA, 200);
    delay(20);

    // Se detiene un momento
    digitalWrite(MotorD1, LOW);
    digitalWrite(MotorD2, LOW);
    delay(1000);

    // Gira hacia el otro lado 2 segundos (para volver a su posición inicial) 
    digitalWrite(MotorD1, HIGH);
    digitalWrite(MotorD2, LOW);
    analogWrite(MotorDENA, 200);
    delay(20);

    // Se detiene
    digitalWrite(MotorD1, LOW);
    digitalWrite(MotorD2, LOW);
    delay(1000);
}
void girarIzquierda() {
//Avanza a una velocidad controlada 
    digitalWrite(pinMotorP1, HIGH);
    digitalWrite(pinMotorP2, LOW);
    analogWrite(MotorDENAP, 80);
    // Gira hacia un lado 2 segundos
    digitalWrite(MotorD1, HIGH);
    digitalWrite(MotorD2, LOW);
    analogWrite(MotorDENA, 200);
    delay(20);

    // Se detiene un momento
    digitalWrite(MotorD1, LOW);
    digitalWrite(MotorD2, LOW);
    delay(1000);

    // Gira hacia el otro lado 2 segundos (para volver a su posición inicial)
    digitalWrite(MotorD1, LOW);
    digitalWrite(MotorD2, HIGH);
    analogWrite(MotorDENA, 200);
    delay(20);

    // Se detiene
    digitalWrite(MotorD1, LOW);
    digitalWrite(MotorD2, LOW);
    delay(1000);
 
}

void centrarDireccion() {
  digitalWrite(MotorD1, LOW);
  digitalWrite(MotorD2, LOW);
}

// SETUP
void setup() {
//Definir los motores como salidas
  Serial.begin(115200);

  pinMode(pinMotorP1, OUTPUT);
  pinMode(pinMotorP2, OUTPUT);

  pinMode(MotorD1, OUTPUT);
  pinMode(MotorD2, OUTPUT);
  pinMode(MotorDENA, OUTPUT);
  pinMode(MotorDENAP, OUTPUT);
}


// LOOP AUTÓNOMO

void loop() {

  // Lectura de sensores
  DISTANCIASensorA = 0.01723 * leerUltrasonico(SensorApinGatillo, SensorApinEco);
  DISTANCIASensorD = 0.01723 * leerUltrasonico(SensorDpinGatillo, SensorDpinEco);
  DISTANCIASensorI = 0.01723 * leerUltrasonico(SensorIpinGatillo, SensorIpinEco);

Serial.print("A: "); Serial.print(DISTANCIASensorA);
Serial.print("  D: "); Serial.print(DISTANCIASensorD);
Serial.print("  I: "); Serial.println(DISTANCIASensorI);

  //   COMPORTAMIENTO AUTÓNOMO

  // 1. Si adelante hay espacio libre → avanzar recto
  if (DISTANCIASensorA > 30) {
    centrarDireccion();
    avanzar();
  }

  // 2. Si adelante hay poco espacio → decidir por el lado con mayor distancia
  else {

    // Si derecha tiene más espacio → girar a la derecha
    if (DISTANCIASensorD > DISTANCIASensorI) {
      girarDerecha();
      avanzar();
    }

    // Si izquierda tiene más espacio → girar a la izquierda
    else if (DISTANCIASensorI > DISTANCIASensorD) {
      girarIzquierda();
      avanzar();
    } else if (DISTANCIASensorA<10){
        retroceder();

    } else if (DISTANCIASensorI<10){
        retroceder();
    }else if (DISTANCIASensorD<10){
        retroceder();
    }
    // Si ambos lados están iguales → retroceder un poco
    else {
      retroceder();
      delay(300);
      detenerMotorP();
    }
  }

  delay(40);
}
